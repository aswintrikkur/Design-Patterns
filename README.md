# Design Patterns

A concise reference and introduction to common software design patterns.

## Table of Contents

- [What's a design pattern?](#whats-a-design-pattern)
- [Classification of patterns](#classification-of-patterns)
	- [Creational patterns](#creational-patterns)
	- [Structural patterns](#structural-patterns)
	- [Behavioral patterns](#behavioral-patterns)
- [When to use patterns](#when-to-use-patterns)

## What's a design pattern?

Design patterns are typical solutions to commonly occurring problems in software design. They act like reusable blueprints that can be adapted to solve recurring design problems in your code.

Patterns differ from algorithms: an algorithm specifies a concrete set of steps to achieve a result, while a pattern describes a higher-level approach. The same pattern can be implemented with different code depending on the context.

## Classification of patterns

All patterns can be categorized by their intent (purpose). The three primary categories are:

### Creational patterns

Creational patterns provide object-creation mechanisms that increase flexibility and reuse. They help manage the process of object creation in a way suited to the situation.

Common examples: Singleton, Factory Method, Abstract Factory, Builder, Prototype.

### Structural patterns

Structural patterns explain how to assemble objects and classes into larger structures while keeping them flexible and efficient. They focus on the composition of components.

Common examples: Adapter, Bridge, Composite, Decorator, Facade, Flyweight, Proxy.

### Behavioral patterns

Behavioral patterns deal with communication between objects and the assignment of responsibilities. They help manage algorithms, relationships, and responsibilities.

Common examples: Observer, Strategy, Command, Iterator, Mediator, Memento, State, Visitor.

## When to use patterns

- Use a pattern when a problem recurs and a proven structural approach can improve clarity and maintainability.
- Prefer simple, idiomatic code first; apply patterns when they solve real design issues, not preemptively.


ref: [Design Patterns](https://refactoring.guru/design-patterns)


---



